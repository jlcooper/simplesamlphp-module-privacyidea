<?php
/**
 * This authentication processing filter allows you to add a second step
 * authentication against privacyIDEA
 *
 * @author Cornelius KÃ¶lbel <cornelius.koelbel@netknights.it>
 */



class sspmod_privacyidea_Auth_Process_privacyidea extends SimpleSAML_Auth_ProcessingFilter
{
    /**
     * The URL of the privacyIDEA system
     *
     * @var string
     */
    private $privacyIDEA_URL;

    /**
     * Check if the hostname matches the name in the certificate
     * @var boolean
     */

    private $sslverifyhost;

    /**
     * Check if the certificate is valid, signed by a trusted CA
     * @var boolean
     */
    private $sslverifypeer;

    /**
     * The realm where the user is located in.
     * @var string
     */
    private $realm;

	/**
	 * uidKey
	 * We need to know in which key in "Attributes" the UID is stored.
	 */
	private $uidKey;

	/**
	 * If a user has no token, the 2FA screen should be skipped.
	 * To enable that, the value needs to be set to true.
	 * The policy passOnNoToken in privacyIDEA should be set.
	 */
	private $loginWithoutToken;

    /**
     * Per se we do not need an attributemap, since all attributes are
     * usually set by the authsource
     */

    /**
     * privacyidea constructor.
     *
     * @param array $config The configuration of this authproc.
     * @param mixed $reserved
     *
     * @throws \SimpleSAML\Error\CriticalConfigurationError in case the configuration is wrong.
     */

     public function __construct(array $config, $reserved)
     {
        SimpleSAML_Logger::info("Create the Auth Proc Filter privacyidea");
        parent::__construct($config, $reserved);
        $cfg = SimpleSAML_Configuration::loadFromArray($config, 'privacyidea:privacyidea');
        $this->privacyIDEA_URL = $cfg->getString('privacyideaserver');
        $this->sslverifyhost = $cfg->getBoolean('sslverifyhost', true);
        $this->sslverifypeer = $cfg->getBoolean('sslverifypeer', true);
        $this->realm = $cfg->getString('realm');
        $this->uidKey = $cfg->getString('uidKey');
        $this->loginWithoutToken = $cfg->getBoolean('loginWithoutToken', false);
     }

    /**
     * Run the filter.
     *
     * @param array $state
     *
     * @throws \Exception if authentication fails
     */
    public function process(&$state)
    {

    	$state['privacyidea:privacyidea'] = array(
    		'privacyIDEA_URL' => $this->privacyIDEA_URL,
		    'sslverifyhost' => $this->sslverifyhost,
		    'sslverifypeer' => $this->sslverifypeer,
		    'realm' => $this->realm,
		    'uidKey' => $this->uidKey,
	    );

        $id = SimpleSAML_Auth_State::saveState($state, 'privacyidea:privacyidea:init');
        if ($this->loginWithoutToken) {
        	if (!self::authenticate($state, "check, if user has a token")) {
		        $url = SimpleSAML_Module::getModuleURL('privacyidea/otpform.php');
		        SimpleSAML_Utilities::redirectTrustedURL($url, array('StateId' => $id));
	        }
        } else {
	        $url = SimpleSAML_Module::getModuleURL('privacyidea/otpform.php');
	        SimpleSAML_Utilities::redirectTrustedURL($url, array('StateId' => $id));
        }



	    SimpleSAML_Logger::info("privacyIDEA Auth Proc Filter: running process");
    }

    /**
     * Perform 2FA authentication given the current state and an OTP from a token managed by privacyIDEA
     * The otp is sent to the privacyidea_url.
     *
     * @param array $state The state array in the "privacyidea:privacyidea:init" stage.
     * @param string $otp A one time password generated by a yubikey.
     * @return boolean True if authentication succeeded and the key belongs to the user, false otherwise.
     *
     * @throws \InvalidArgumentException if the state array is not in a valid stage or the given OTP has incorrect
     * length.
     */

    public static function authenticate(array &$state, $otp)
    {

    	$cfg = $state['privacyidea:privacyidea'];

        SimpleSAML_Logger::info("privacyIDEA Auth Proc Filter: running authenticate");
	    $curl_instance = curl_init();
	    $params = array(
		    "user" => $state["Attributes"][$cfg['uidKey']][0],
		    "pass" => $otp,
		    "realm"=> $cfg['realm'],
	    );
	    SimpleSAML_Logger::debug("privacyIDEA: UID = " . $state["Attributes"][$cfg['uidKey']][0]);

	    $url = $cfg['privacyIDEA_URL'] . "/validate/samlcheck";

	    curl_setopt($curl_instance, CURLOPT_URL, $url);
	    SimpleSAML_Logger::debug("privacyIDEA: URL = " . $url);
	    curl_setopt($curl_instance, CURLOPT_HEADER, TRUE);
	    curl_setopt($curl_instance, CURLOPT_RETURNTRANSFER, TRUE);
	    curl_setopt($curl_instance, CURLOPT_USERAGENT, "simpleSAMLphp");
	    // Add POST params
	    curl_setopt($curl_instance, CURLOPT_POST, 3);
	    curl_setopt($curl_instance, CURLOPT_POSTFIELDS, $params);

	    if ($cfg['sslverifyhost']) {
		    curl_setopt($curl_instance, CURLOPT_SSL_VERIFYHOST, 2);
	    } else {
		    curl_setopt($curl_instance, CURLOPT_SSL_VERIFYHOST, 0);
	    }
	    if ($cfg['sslverifypeer']) {
		    curl_setopt($curl_instance, CURLOPT_SSL_VERIFYPEER, 2);
	    } else {
		    curl_setopt($curl_instance, CURLOPT_SSL_VERIFYPEER, 0);
	    }
	    if(!$response = curl_exec($curl_instance)) {
	        throw new SimpleSAML_Error_BadRequest("privacyIDEA: Bad request to PI server: " . curl_error($curl_instance));
        };
	    SimpleSAML_Logger::debug("privacyIDEA: \n\n\n" . $response . "\n\n\n");
	    $header_size = curl_getinfo($curl_instance, CURLINFO_HEADER_SIZE);
	    $body = json_decode(substr($response, $header_size));
	    try {
	        $result = $body->result;
	        $status = $result->status;
	        $value = $result->value->auth;
        } catch (Exception $e) {
	        throw new SimpleSAML_Error_BadRequest( "privacyIDEA: We were not able to read the response from the PI server");
        }

        if ($status !== True) {
            throw new SimpleSAML_Error_BadRequest("Valid JSON Response, but some internal error occured in PI server");
        } else {
            if ($value !== True){
                SimpleSAML_Logger::debug("privacyIDEA: Wrong user pass");
                return False;
            } else {
	            SimpleSAML_Logger::debug("privacyIDEA: User authenticated successfully");
                return True;
            }
        }


    }
}